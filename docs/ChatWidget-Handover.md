# ChatWidget Feature - Technical Handover

## Overview

The ChatWidget is an AI-powered chat and image generation feature integrated into the CodeDeck Electron app. It connects to a cloud backend (CodeDeck-Backend deployed on Render) which proxies requests to OpenAI APIs.

---

## Architecture

### Components

1. **Frontend (Electron Renderer)**
   - `src/components/ChatWidget.tsx` - Main UI component with chat interface, model selection, history sidebar, and image display

2. **Electron Main Process (IPC Handlers)**
   - `electron/handlers/chatWidgetHandlers.ts` - IPC handlers for chat, image generation, and conversation persistence
   - `electron/services/BackendService.ts` - HTTP client that communicates with the cloud backend

3. **Cloud Backend (CodeDeck-Backend on Render)**
   - `src/routes/ai.js` - Express routes for chat completion, image generation, and model listing
   - `src/config/aiModels.js` - Model definitions and plan-based limits

4. **Database**
   - SQLite (local) - Stores conversations via `electron/services/DatabaseService.ts`
   - MongoDB (cloud) - Stores user data, plans, and AI usage tracking

---

## Data Flow

### Chat Flow
1. User sends message in ChatWidget
2. Frontend calls `window.electronAPI.chatWidget.chat()`
3. IPC handler in `chatWidgetHandlers.ts` calls `backendService.streamChat()`
4. BackendService makes POST to `{BACKEND_URL}/api/ai/chat` with JWT auth
5. Backend validates JWT, checks user plan limits against MongoDB
6. Backend streams response from OpenAI via Server-Sent Events (SSE)
7. Chunks are sent back to renderer via `mainWindowContents.send('chatWidget:stream-chunk')`
8. Conversation is saved to local SQLite database

### Image Generation Flow
1. User sends prompt in ChatWidget (images mode)
2. Frontend calls `window.electronAPI.chatWidget.generateImage()`
3. IPC handler calls `backendService.generateImage()`
4. Backend validates JWT, checks image limits against MongoDB
5. Backend calls OpenAI's `images.generate()` with model `gpt-image-1`
6. Image returns as base64, backend increments usage in MongoDB
7. Electron saves image to `{projectPath}/.codedeck/generations/`
8. Returns both base64 data URL (for display) and local file path (for file operations)

---

## Key Files

### Frontend
- `src/components/ChatWidget.tsx` - All UI logic, state management, message rendering
- `src/types/electron.d.ts` - TypeScript definitions for IPC APIs

### Electron Main
- `electron/handlers/chatWidgetHandlers.ts` - IPC handlers for all chat operations
- `electron/services/BackendService.ts` - Backend API client with streaming support
- `electron/services/DatabaseService.ts` - SQLite operations for conversation persistence
- `electron/handlers/fileHandlers.ts` - File operations (read base64, save images)

### Backend (CodeDeck-Backend repo)
- `src/routes/ai.js` - All AI endpoints
- `src/config/aiModels.js` - Model configs and plan limits
- `src/middleware/auth.js` - JWT verification middleware

---

## Plan-Based Access Control

### Plan Levels
- **Free**: No AI access (0 chat tokens, 0 images)
- **Plus**: Chat access only (100k tokens/day, 0 images)
- **Premium**: Full access (500k tokens/day, 50 images/day)

### Where Limits are Defined
Backend file: `src/config/aiModels.js` contains `PLAN_LIMITS` object with `chatTokensPerDay` and `imagesPerDay` for each plan.

### How Limits are Enforced
1. Every API request includes JWT in Authorization header
2. Backend middleware extracts user ID from JWT
3. Backend fetches fresh user data from MongoDB (cannot be spoofed)
4. Backend checks `AIUsage` collection for today's usage
5. If limit exceeded, returns 403 error
6. On success, increments usage count in MongoDB

### Frontend Access Checks
Frontend shows all features but blocks input for users without access. Shows upgrade prompts linking to pricing page. Access is checked via `user.plan` from app store.

---

## Model Configuration

### Adding/Modifying Models
Edit `src/config/aiModels.js` in the backend:

- `AI_MODELS.chat` array - Chat models with id, displayName, description, provider, modelId
- `AI_MODELS.images` array - Image models with same structure

The `modelId` is what gets sent to OpenAI. The `id` is the internal identifier used by frontend.

### Current Models
- Chat: `gpt-4.1-mini` (GPT-4.1 Mini), `gpt-4.1` (GPT-4.1)
- Images: `gpt-image-1` (GPT Image)

---

## Conversation Persistence

### Database Schema
Table `chatwidget_conversations` in SQLite with fields:
- `id` - Generated by database (important: frontend must use returned ID)
- `projectId` - Links conversation to project
- `title` - First 30 chars of first message
- `modelCategory` - 'chat' or 'images'
- `model` - Model ID used
- `messages` - JSON string of message array
- `createdAt`, `updatedAt` - Timestamps

### Message Structure
Each message contains: `id`, `role`, `content`, `timestamp`, `type` ('text' or 'image'), `imageUrl` (base64 data URL), `imageLocalPath` (file system path)

### Important: Conversation ID Sync
When creating a new conversation, the database generates its own ID. The frontend MUST await the `createConversation` call and update local state with the returned ID. Otherwise, subsequent `updateConversation` calls will fail silently (this was a bug that caused image responses to not persist).

---

## Image Handling

### Storage Locations
- Generated images: `{projectPath}/.codedeck/generations/`
- User assets: `{projectPath}/public/assets/images/`

### Display in Electron
Electron blocks `file://` URLs for security. Images must be loaded as base64 data URLs. When displaying, convert file path to base64 using `window.electronAPI.files.readFileAsBase64()`.

### Image Actions
- **Show in Finder**: `shell.showItemInFolder(path)`
- **Open**: `shell.openPath(path)`
- **Save to Assets**: Reads image as base64, finds images folder via `getAssetsStructure()`, saves copy

### Persistence
Images are saved with `imageLocalPath` in the message. When loading old conversations, the system reads the image from disk and converts to base64 data URL for display. If file is deleted, image won't show but message remains.

---

## Streaming Implementation

### Backend (SSE)
The `/api/ai/chat` endpoint uses Server-Sent Events. It sets headers for `text/event-stream` and pipes OpenAI's stream chunks to the response.

### Electron (IPC Events)
- `chatWidget:stream-chunk` - Sends each text chunk to renderer
- `chatWidget:stream-done` - Signals completion with usage stats
- `chatWidget:stream-error` - Sends error message

### Frontend Listeners
Set up in useEffect, listeners append chunks to `streamingContent` state. On done, creates final assistant message and saves to database.

---

## Security Notes

1. **JWT Verification**: All backend requests require valid JWT. Secret is server-side only.
2. **Fresh User Data**: Backend always fetches user from MongoDB, never trusts JWT claims for plan info.
3. **Usage Tracking**: Stored in MongoDB `AIUsage` collection, checked and updated atomically.
4. **No Client-Side Bypasses**: All limits enforced server-side. Frontend checks are UX only.

---

## Common Issues & Solutions

### Images not displaying
- Check if `imageLocalPath` is being saved in message
- Ensure base64 conversion is happening on load
- Verify file exists at the path

### Conversation not saving properly
- Verify frontend is using database-returned ID after `createConversation`
- Check that `updateConversation` is being called with correct ID

### Model not switching correctly
- When loading conversation from history, must also restore `modelCategory` and selected model
- Check the conversation loading code sets these states

### Usage limits not enforcing
- Verify JWT is being sent in Authorization header
- Check MongoDB `AIUsage` collection for correct date entries
- Ensure `PLAN_LIMITS` in backend config is correct

---

## Environment Variables

### Backend (Render)
- `OPENAI_API_KEY` - OpenAI API key
- `JWT_SECRET` - Secret for JWT verification
- `MONGODB_URI` - MongoDB connection string

### Electron
- Backend URL configured in `BackendService.ts` (currently hardcoded to Render deployment)

---

## Future Considerations

1. **Model Expansion**: Easy to add new models in `aiModels.js`
2. **Usage Analytics**: MongoDB already tracks usage, could build dashboard
3. **Conversation Export**: Messages are JSON, easy to export
4. **Image Editing**: Framework exists in ProjectAssetsWidget for image editing
